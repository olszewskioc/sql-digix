-- Active: 1739211085766@@127.0.0.1@5432@digix@au10
/*
------------------------------------------------------------------

 						        AULA 10 (19/02/25)
                                TEMA: TRIGGERS
						       THIAGO OLSZEWSKI

------------------------------------------------------------------
*/

CREATE SCHEMA AU10;

-- GATILHOS AUTOMÁTICOS QUE SÃO EXECUTADOS ANTES, DEPOIS OU EM LUGAR DA INSTRUÇÃO
-- QUANDO SÃO NECESSÁRIAS?
-- 1 - QUANDO É NECESSÁRIO MANTER INTEGRIDADE DE DADOS
-- 2 - QUANDO É NECESSÁRIO MANTER A CONSISTÊNCIA DE DADOS
-- 3 - PARA VALIDAR REGRAS DE NEGÓCIO
-- 4 - PARA AUTOMATIZAR TAREFAS QUE DEVEM SER EXECUTADAS

-- EXEMPLO: REGISTRO DE EVENTOS PARA TABELA DE AUDITORIA

CREATE TABLE IF NOT EXISTS LOG_PARTIDA(
    ID_LOG SERIAL PRIMARY KEY,
    PARTIDA_ID  INTEGER,
    ACAO VARCHAR(20),
    DATA_HORA TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DROP TABLE LOG_PARTIDA;

CREATE OR REPLACE FUNCTION LOG_PARTIDA_INSERT()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO LOG_PARTIDA(PARTIDA_ID, ACAO)
    VALUES(NEW.ID, 'INSERT');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- GATILHO DE INCLUSÃO
CREATE OR REPLACE TRIGGER TRG_LOG_PARTIDA_INSERT
AFTER INSERT ON PARTIDA
FOR EACH ROW
EXECUTE FUNCTION LOG_PARTIDA_INSERT();

INSERT INTO PARTIDA(ID, TIME_1, TIME_2, TIME_1_GOLS, TIME_2_GOLS)
VALUES(10, 1, 2, 4, 3);

SELECT * FROM LOG_PARTIDA;

-- TRIGGER BEFORE
CREATE OR REPLACE FUNCTION PARTIDA_INSERT()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.TIME_1 = NEW.TIME_2 THEN
        RAISE EXCEPTION 'NÃO É PERMITIDO JOGOS ENTRE O MESMO TIME';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER INSERT_PARTIDA
BEFORE INSERT ON PARTIDA
FOR EACH ROW
EXECUTE FUNCTION PARTIDA_INSERT();

INSERT INTO PARTIDA(ID, TIME_1, TIME_2, TIME_1_GOLS, TIME_2_GOLS)
VALUES(10, 1, 1, 4, 3);

-- EXEMPLO DE INSTEAD OF (UTILIZAR COM VIEW)
CREATE OR REPLACE VIEW PARTIDA_V AS
SELECT * FROM PARTIDA;

-- AGORA QUEREMOS PERMITIR INSERCÕES NA PARTIDA_V
-- MAS OS DADOS REAIS DEVEM SER ARMAZENADOS NA TABELA PARTIDA
CREATE OR REPLACE FUNCTION PARTIDA_V_INSERT()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO PARTIDA(ID, TIME_1, TIME_2, TIME_1_GOLS, TIME_2_GOLS)
    VALUES(NEW.ID, NEW.TIME_1, NEW.TIME_2, NEW.TIME_1_GOLS, NEW.TIME_2_GOLS);
    RETURN NULL;    -- NÃO INSERIR NA VISÃO DIRETAMENTE
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_PARTIDA_V_INSERT
INSTEAD OF INSERT ON PARTIDA_V -- NO LUGAR DE UMA INSERÇÃO NA VISÃO
FOR EACH ROW
EXECUTE FUNCTION PARTIDA_V_INSERT();

INSERT INTO PARTIDA_V(ID, TIME_1, TIME_2, TIME_1_GOLS, TIME_2_GOLS)
VALUES(11, 1, 2, 4, 3);

SELECT * FROM PARTIDA_V;

-- TRIGGER AFTER UPDATE
CREATE OR REPLACE FUNCTION PARTIDA_UPDATE()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO LOG_PARTIDA(PARTIDA_ID, ACAO) VALUES (NEW.ID, 'UPDATE');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_PARTIDA_V_UPDATE
AFTER UPDATE ON PARTIDA
FOR EACH ROW
EXECUTE FUNCTION PARTIDA_UPDATE();

UPDATE PARTIDA SET TIME_1_GOLS = 4 WHERE ID = 10;
SELECT * FROM LOG_PARTIDA;

-- TRIGGER QUE IMPEDE DE FAZER UPDATE EM PARTIDAS JÁ FINALIZADAS
CREATE OR REPLACE FUNCTION PARTIDA_UPDATE_CHECK()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Não é possível atualizar uma partida finalizada';
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_NO_UPDATE_PARTIDA
BEFORE UPDATE ON PARTIDA
FOR EACH ROW
EXECUTE FUNCTION PARTIDA_UPDATE_CHECK();

-- PROHIBITED DELETE
CREATE OR REPLACE FUNCTION PARTIDA_DELETE_CHECK()
RETURNS TRIGGER AS $$
BEGIN
    RAISE EXCEPTION 'Não é possível excluir uma partida';
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_PARTIDA_DELETE
BEFORE DELETE ON PARTIDA
FOR EACH ROW
EXECUTE FUNCTION PARTIDA_DELETE_CHECK();


DELETE FROM PARTIDA WHERE ID = 10;