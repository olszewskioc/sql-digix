-- Active: 1739211085766@@127.0.0.1@5432@digix@au11
/*
------------------------------------------------------------------

 						        EX11 (19/02/25)
                                TEMA: EXERCICIO
						       THIAGO OLSZEWSKI

------------------------------------------------------------------
*/

/*
    1 - CRIAR UM TRIGGER PARA AUDITORIA DE EXCLUSÃO DE MÁQUINAS
*/

CREATE TABLE IF NOT EXISTS MAQUINA_AUDITORIA(
    ID  INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    ID_MAQUINA  INT NOT NULL,
    DATA_EXCLUSAO  TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE FUNCTION MAQUINA_DELETE_AUDIT()
RETURNS TRIGGER AS $$
BEGIN
    DELETE FROM SOFTWARE WHERE FK_MAQUINA = OLD.ID_MAQUINA;
    INSERT INTO MAQUINA_AUDITORIA(ID_MAQUINA) VALUES (OLD.ID_MAQUINA);
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_MAQUINA_AUDIT
BEFORE DELETE ON MAQUINA
FOR EACH ROW
EXECUTE PROCEDURE MAQUINA_DELETE_AUDIT();

DELETE FROM MAQUINA WHERE ID_MAQUINA = 4;

/*
    2 - CRIAR UM TRIGGER PARA EVITAR SENHAS FRACAS
*/
CREATE OR REPLACE FUNCTION USER_CHECK_PASSWORD()
RETURNS TRIGGER AS $$
BEGIN
    IF LENGTH(NEW.PASSWORD) < 6 THEN
        RAISE EXCEPTION 'A SENHA NÃO PODE TER MENOS QUE 6 CARACTERES';
    RETURN NULL;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_USER_CHECK_PASSWORD
BEFORE INSERT OR UPDATE OF PASSWORD ON USUARIOS
FOR EACH ROW
EXECUTE PROCEDURE USER_CHECK_PASSWORD();

INSERT INTO USUARIOS(ID_USUARIO, PASSWORD, NOME_USUARIO, RAMAL, ESPECIALIDADE) 
VALUES(6, 'TESTE', 'THIAGO', 1234, 'BACKEND');

/*
    3 - CRIAR UM TRIGGER PARA ATUALIZAR CONTAGEM DE SOFTWARES EM CADA MÁQUINA
*/

CREATE TABLE IF NOT EXISTS MAQUINA_SOFTWARE_COUNT(
    ID SERIAL PRIMARY KEY,
    ID_MAQUINA INT NOT NULL UNIQUE,
    QTD_SOFTWARE INT NOT NULL DEFAULT 0,
    DATA_HORA    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT FK_MAQUINA_SOFTWARE FOREIGN KEY (ID_MAQUINA) 
    REFERENCES MAQUINA (ID_MAQUINA) ON DELETE CASCADE
);

INSERT INTO MAQUINA_SOFTWARE_COUNT (ID_MAQUINA, QTD_SOFTWARE)
SELECT 
    M.ID_MAQUINA, 
    COALESCE(COUNT(S.FK_MAQUINA), 0) AS QTD_SOFTWARE
FROM MAQUINA M
LEFT JOIN SOFTWARE S ON M.ID_MAQUINA = S.FK_MAQUINA
GROUP BY M.ID_MAQUINA
ON CONFLICT (ID_MAQUINA) DO NOTHING;

CREATE OR REPLACE FUNCTION FUNC_MAQUINA_SOFTWARE_COUNT()
RETURNS TRIGGER AS $$
BEGIN
    -- INSERE A MÁQUINA PARA GARANTIR QUE TODAS SERÃO ATUALIZADAS
    INSERT INTO MAQUINA_SOFTWARE_COUNT (ID_MAQUINA, QTD_SOFTWARE)
    VALUES (NEW.FK_MAQUINA, 0)
    ON CONFLICT (ID_MAQUINA) 
    DO UPDATE
    SET QTD_SOFTWARE = (SELECT COUNT(*) FROM SOFTWARE WHERE FK_MAQUINA = NEW.FK_MAQUINA);

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_MAQUINA_SOFTWARE_COUNT
AFTER INSERT ON SOFTWARE
FOR EACH ROW
EXECUTE PROCEDURE FUNC_MAQUINA_SOFTWARE_COUNT();

insert into AU11.Software values (10, 'TESTE2', 200, 2, 5);
DELETE FROM AU11.Software WHERE id_software = 9;

/*
    4 - CRIAR UM TRIGGER PARA EVITAR A REMOÇÃO DE USUÁRIOS DO SETOR DE TI
*/
CREATE OR REPLACE FUNCTION USER_CHECK_TI()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.ESPECIALIDADE LIKE '%TI%' THEN
        RAISE EXCEPTION 'ERRO AO REMOVER O USER %: O USUARIO É DO SETOR DE TI', OLD.ID_USUARIO;
    END IF;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_USER_CHECK_TI
BEFORE DELETE ON USUARIOS
FOR EACH ROW
EXECUTE PROCEDURE USER_CHECK_TI();

DELETE FROM USUARIOS WHERE ESPECIALIDADE LIKE '%TI%';

/*
    5 - CRIAR UM TRIGGER PARA CALCULAR O USO TOTAL DE MEMÓRIA POR MÁQUINA
    COM UM AFTER INSERT E UM AFTER DELETE
*/

CREATE TABLE IF NOT EXISTS MAQUINA_MEMORIA(
    ID SERIAL PRIMARY KEY,
    ID_MAQUINA INTEGER UNIQUE,
    USO_MEMORIA INTEGER,
    CONSTRAINT FK_MAQUINA_MEMORIA FOREIGN KEY (ID_MAQUINA) 
    REFERENCES MAQUINA (ID_MAQUINA) ON DELETE CASCADE
);
DROP TABLE MAQUINA_MEMORIA;

CREATE OR REPLACE FUNCTION MAQUINA_MEMORIA_USE()
RETURNS TRIGGER AS $$
DECLARE MEMORY INTEGER;
BEGIN
    -- CALCULA A SOMA DA MEMÓRIA UTILIZADA PELA MÁQUINA EM QUESTÃO
    SELECT COALESCE(SUM(MEMORIA_RAM), 0) INTO MEMORY 
    FROM SOFTWARE WHERE FK_MAQUINA = NEW.FK_MAQUINA;

    -- TG_OP PARA VERIFICAR A OPERAÇÃO QUE ATIVOU A TRIGGER
    IF TG_OP = 'INSERT' THEN
        INSERT INTO MAQUINA_MEMORIA (ID_MAQUINA, USO_MEMORIA)
        VALUES (NEW.FK_MAQUINA, MEMORY)
        ON CONFLICT (ID_MAQUINA) DO UPDATE  -- CASO ENCONTRE O ID ELE REALIZA UM UPDATE
        SET USO_MEMORIA = MEMORY;
        RAISE NOTICE 'MEMÓRIA % ATUALIZADA PARA %', NEW.FK_MAQUINA, MEMORY;
        RETURN NEW;

        ELSIF TG_OP = 'DELETE' THEN
            UPDATE MAQUINA_MEMORIA SET USO_MEMORIA = MEMORY
            WHERE ID_MAQUINA = OLD.FK_MAQUINA;
            RAISE NOTICE 'MEMÓRIA % ATUALIZADA PARA %', OLD.FK_MAQUINA, MEMORY;
            RETURN OLD;
    ELSE
        RAISE EXCEPTION 'OPERAÇÃO NÃO SUPORTADA: %', TG_OP;
    END IF;
    EXCEPTION
    WHEN OTHERS THEN
    RAISE NOTICE 'Erro ao calcular uso de memória: %', SQLERRM;

    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_MAQUINA_MEMORIA_USE
AFTER INSERT OR DELETE ON SOFTWARE
FOR EACH ROW
EXECUTE PROCEDURE MAQUINA_MEMORIA_USE();

insert into Software values (5, 'VSCODE', 100, 2, 2);
DELETE FROM MAQUINA_MEMORIA;

/*
    6 - CRIAR UMA TRIGGER PARA REGISTRAR ALTERAÇÕES NAS ESPECIALIDADES DO USUÁRIO
*/
CREATE TABLE IF NOT EXISTS USUARIO_ALTER_ESPECIALIDADE(
    ID SERIAL PRIMARY KEY,
    ID_USUARIO INTEGER NOT NULL,
    ESPECIALIDADE_ANTIGA VARCHAR(255) NOT NULL,
    ESPECIALIDADE_NOVA VARCHAR(255) NOT NULL,
    DATA_ALTERACAO TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (ID_USUARIO) REFERENCES USUARIOS (ID_USUARIO) ON DELETE CASCADE
);

CREATE OR REPLACE FUNCTION USUARIO_ESPECIALIDADE_ALTER()
RETURNS TRIGGER AS $$
BEGIN
    -- OLD PARA ANTES DO UPDATE E NEW PARA OQUE SERÁ MUDADO
    INSERT INTO USUARIO_ALTER_ESPECIALIDADE(ID_USUARIO, ESPECIALIDADE_ANTIGA, ESPECIALIDADE_NOVA)
    VALUES (OLD.ID_USUARIO, OLD.ESPECIALIDADE, NEW.ESPECIALIDADE);
    RAISE NOTICE 'ALTERA ESPECIALIDADE USER %: % -> %', OLD.ID_USUARIO, OLD.ESPECIALIDADE, NEW.ESPECIALIDADE;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_USUARIO_ESPECIALIDADE_ALTER
AFTER UPDATE OF ESPECIALIDADE ON USUARIOS
FOR EACH ROW
EXECUTE PROCEDURE USUARIO_ESPECIALIDADE_ALTER();

UPDATE USUARIOS SET ESPECIALIDADE = 'TI' WHERE ID_USUARIO = 2;

/*
    7 - CRIAR UMA TRIGGER PARA IMPEDIR A EXCLUSÃO DE SOFTWARES ESSENCIAIS
*/
CREATE OR REPLACE FUNCTION IMPEDIR_SOFTWARE_ESSENCIAL()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.PRODUTO LIKE ANY (ARRAY['%Windows%', '%Linux%']) THEN
        RAISE EXCEPTION 'Não é possível excluir software essencial %', OLD.PRODUTO;
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER TRIGG_SOFTWARE_ESSENCIAL_DELETE
BEFORE DELETE ON SOFTWARE
FOR EACH ROW
EXECUTE PROCEDURE IMPEDIR_SOFTWARE_ESSENCIAL();

DELETE FROM SOFTWARE WHERE ID_SOFTWARE = 1; -- ID 1 = Windows